Package postfix;

Helpers
 letter = [['a' .. 'z'] + ['A' .. 'Z']];
 digit = ['0' .. '9'];
 newline = ( 10 | '\n');

Tokens
 id = letter (letter | digit | '_')*;
 bool_type = 'bool';
 str_type = 'string';
 num_type = 'num';
 list_dcl = '[]';
 l_par = '(';
 r_par = ')';
 l_curly = '{';
 r_curly = '}';
 return = 'return';
 newline = newline;
 assign = ':=';
 numval = (('-' digit+) | digit+);
 stringval = ('"' (letter | digit | '\"')* '"');
 true = 'true';
 false = 'false';
 if = 'if';
 else = 'else';
 while = 'while';
 and = 'and';
 or = 'or';
 neg = '!';
 equal = '==';
 lte = '<=';
 gte = '>=';
 lt = '<';
 gt = '>';
 ne = '!='; 
 plus = '+';
 minus = '-';
 mult = '*';
 div = '/';
 mod = '%';
 blank = (' ')+;
 comma = ',';

Ignored Tokens
 blank;

Productions
 start =
  {func} func start |
  {stmts} stmts start |
  {stmt} stmts;

 func =
  {typed} type id args block |
  {void} id args block;

 type =
  {bool_lst} bool_type list_dcl |
  {str_lst} str_type list_dcl |
  {num_lst} num_type list_dcl |
  {bool} bool_type |
  {str} str_type |
  {num} num_type;

 args =
  {void} l_par r_par|
  {non_void} l_par arg_list r_par;

 arg_list =
  {not_last} type id comma arg_list |
  {last} type id;

 block =
  {begin} l_curly newline stmts endblock;

 endblock =
  {retur} return val r_curly newline |
  {void} r_curly newline;

 stmts = 
  {dcl_rec} dcl newline stmts |
  {assign_rec} assign_stmt newline stmts |
  {cntrol_rec} cntrol stmts |
  {func_call_rec} func_call stmts |
  {dcl} dcl |
  {assign} assign_stmt |
  {cntrol} cntrol |
  {func_call} func_call;

 dcl =
  {bool} bool_type assign_stmt |
  {str} str_type assign_stmt |
  {num} num_type assign_stmt;

 assign_stmt =
  {assign} id equal_stmt;

 equal_stmt =
  {equal} assign expr;

 expr =
  {plus} expr1 plus expr |
  {sub} expr1 minus expr |
  {expr1} expr1;

 expr1 =
  {mult} expr2 mult expr1 |
  {div} expr2 div expr1 |
  {mod} expr2 mod expr1 |
  {val} expr2;

 expr2 =
  {val} val |
  {paran} l_par expr r_par;

 val =
  {id} id |
  {num} numval |
  {str} stringval |
  {true} true |
  {false} false |
  {list} l_curly list r_curly |
  {fun} func_call;

 cntrol =
  {if} if_stmt |
  {while} while_stmt;

 if_stmt =
  {if} if cond block |
  {if_else} if cond block else_stmt;

 else_stmt =
  {else_if} else if_stmt |
  {else} else block;

 while_stmt =
  {while} while cond block;

 cond =
  {or} cond1 or cond |
  {and} cond1;

 cond1 =
  {and} cond2 and cond1 |
  {equal} cond2;

 cond2 =
  {equal} cond3 equal cond2 |
  {ne} cond3 ne cond2 |
  {rel} cond3;

 cond3 =
  {lte} cond4 lte cond3 |
  {gte} cond4 gte cond3 |
  {gt} cond4 gt cond3 |
  {lt} cond4 lt cond3 |
  {unary} cond4;

 cond4 =
  {not} neg cond4 |
  {cond5} cond5;

 cond5 =
  {paran} l_par cond r_par |
  {expr} expr;

 func_call =
  {func_call} id l_par list r_par;

 list =
  {last} val |
  {not_last} val comma list;




  