grammar AlgoPractise;
// Lexer
ID: LETTER (LETTER | DIGIT | '_')*;
BOOL_TYPE: 'bool';
STR_TYPE: 'string';
NUM_TYPE: 'num';
LIST_DCL: '[]';
L_PAR: '(';
R_PAR: ')';
L_CURLY: '{';
R_CURLY: '}';
RETURN: 'return';
ASSIGN: ':=';
NUMVAL: ('-' DIGIT+ | DIGIT+);
STRINGVAL: '"' (LETTER | DIGIT | '\\"')* '"';
TRUE: 'true';
FALSE: 'false';
IF: 'if';
ELSE: 'else';
WHILE: 'while';
AND: 'and';
OR: 'or';
NEG: '!';
EQUAL: '==';
LTE: '<=';
GTE: '>=';
LT: '<';
GT: '>';
NE: '!=';
PLUS: '+';
MINUS: '-';
MULT: '*';
DIV: '/';
MOD: '%';
BLANK: (' ')+ -> skip;
COMMA: ',';
NEWLINE: '\n';
fragment DIGIT: '0'..'9';
fragment LETTER: 'a'..'z' | 'A'..'Z';
// Parser
start: (func | stmts | stmt)* EOF;
func: (type ID args block | ID args block);
type: BOOL_TYPE LIST_DCL | STR_TYPE LIST_DCL | NUM_TYPE LIST_DCL | BOOL_TYPE | STR_TYPE | NUM_TYPE;
args: (L_PAR R_PAR | L_PAR arg_list R_PAR);
arg_list: (type ID (COMMA arg_list)* | type ID);
block: L_CURLY NEWLINE stmts endblock;
endblock: (RETURN val R_CURLY NEWLINE | R_CURLY NEWLINE);
stmts: (dcl NEWLINE stmts | assign_stmt NEWLINE stmts | cntrol stmts | func_call stmts | stmt);
stmt: (dcl | assign_stmt | cntrol | func_call);
dcl: (BOOL_TYPE assign_stmt | STR_TYPE assign_stmt | NUM_TYPE assign_stmt);
assign_stmt: ID ASSIGN cond;
cond: orCond;
orCond: andCond (OR cond)*;
andCond: (cond2 AND andCond | cond2);
cond2: (cond3 EQUAL cond2 | cond3 NE cond2 | cond3);
cond3: (cond4 LTE cond3 | cond4 GTE cond3 | cond4 GT cond3 | cond4 LT cond3 | cond4);
cond4: (NEG cond4 | atom);
atom: (L_PAR cond R_PAR | expr);
expr: (expr1 PLUS expr | expr1 MINUS expr | expr1);
expr1: (expr2 MULT expr1 | expr2 DIV expr1 | expr2 MOD expr1 | expr2);
expr2: (val | L_PAR expr R_PAR);
val: (ID | NUMVAL | STRINGVAL | TRUE | FALSE | L_CURLY list R_CURLY | func_call);
cntrol: (if_stmt | while_stmt);
if_stmt: (IF cond block | IF cond block else_stmt);
else_stmt: (ELSE if_stmt | ELSE block);
while_stmt: WHILE cond block;
func_call: ID L_PAR list R_PAR;
list: val (COMMA list)*;